helpers = require("utility.helpers") -- imports dump() & len() functions

DELAY_BETWEEN_SHOTS = 0.25

function init(self)
	msg.post('.', 'acquire_input_focus')
	pprint("shoot_ability.script: url is " .. msg.url())
	self.shot_types = { 'shoot_a', 'shoot_b' }  -- Possible shoot game objects from the main/abilities/shoot folder.
	self.shot_currently_active = false  -- Toggles to true if a shot is spawned, false otherwise.
end

function on_message(self, message_id, message, sender)
	if message_id == hash("shoot") then
		shot_type = self.shot_types[math.random(1, len(self.shot_types))]
		shoot(self, shot_type, message.spawn_position, DELAY_BETWEEN_SHOTS)
	end
end

function shoot(self, shot_type, spawn_position, delay_between_shots)
	-- Spawns a shot sprite matching shot_type at the spawn_position set by the tap.
	-- Deletes it after a delay matching the delay_between_shots value.
	-- Player cannot cast shoot again until after this delay.
	if self.shot_currently_active == false then -- If not shot is spawned already, then shoot
		pprint('shoot_ability.script: shooting at position: ' .. spawn_position)
		msg.post("/fmod#fmod", "play_pistol_fire")
		shot = factory.create("/shoot_ability#" .. shot_type, spawn_position, nil, nil, vmath.vector3(0.4, 0.35, 1))
		self.shot_currently_active = true
		timer.delay(delay_between_shots, false, function(self, handle, time_elapsed) delete_shot(self, shot) end)
	end
end

function delete_shot(self, shot)
	-- Callback function for shoot, and resets self.waiting to false.
	go.delete(shot)
	self.shot_currently_active = false
end

function final(self)
	msg.post(".", "release_input_focus")
end